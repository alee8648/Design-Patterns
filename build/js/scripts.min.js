
// An example of the module design pattern, by enclosing all the application's major logic inside a module this reduces the amount of variables on the global scope which helps to avoid collision with other functions and objects with equivalent names. 

// By enclosing the code inside a closure, we are able to choose which methods should be publicly accessible and which are private and are only used internally. 

// Setting the module to a globally scoped variable allows access to it throughout the application. 
// Passing globally scoped variables to the function expression as parameters is faster and clearer than relying on JavaScript's implied globals feature.
var Module = (function ($, window) {

	function Module() {

		// Public methods are created as properties of the parent object using the 'this' keyword and dot notation.
		this.init = function() {
			console.log('Module initialised');
		}; 

		// Private methods are declared in function declarations using the 'var' keyword and may only be used within this scope.
		function privateMethod() {
			console.log('A private method');
		}

		privateMethod();
	}
	
	// Return the function created within the closure to be saved to the global variable 'SampleModule'
	return Module;

}(jQuery, window))

// The module is now available to be used as a constructor function to create an instance of the module and save it to a variable.
var module = new Module();

// Methods of the module can now be called
module.init();


// The Revealing Module is very similar to the Module pattern except it specifies exactly what methods to return, rather than deciding if they will be public or private when they are declared.
var RevealingModule = (function ($, window) {

	this.init = function() {
		console.log('RevealingModule initialised');
	}; 

	function publicMethod() {
		return "publicMethod returned";
	}

	function privateMethod() {
		console.log('A private method');
	}

	
	function publicMethod2() {
		console.log(publicMethod());
	}

	// In place of returning the whole module as in the Module pattern, the Revealing Module pattern returns an object containing all the methods you explicitly want to make public, giving a greater degree of control and a clearer way of cherry picking the methods to be public.
	// Returning a private method for public use is often called 'revealing' a method
	return {
		init: init,
		publicMethod: publicMethod,
		publicMethod2: publicMethod2
	};

// When declaring functions directly in the 'return' object, there is a scoping issue caused by public methods calling other public methods. The new scope they are called in does not have access to the other public method. This is resolved by calling the function with the 'RevealingModule.' prepended, or by returning the functions as I have done above.


}(jQuery, window))

RevealingModule.init();
RevealingModule.publicMethod2();
//alert('utils.js has been added amended whilst live as a five-alive-fruit and then and fired')
